=== 过滤器顺序

在 `bool` 过滤器中，过滤器的顺序对性能是非常重要的。((("structured search", "filter order")))((("filters", "order of")))更具体的过滤器应该放在次具体的过滤器之前，这样可以尽早排除更可能多的文档。

如果语句 A 可以匹配 1000 万个文档，语句 B 只能匹配 100 个文档，那么语句 B 须要放在语句 A 之前。

缓存的过滤器非常快，它们应该被置于不能缓存的过滤器之前，((("caching", "cached filters, order of")))假设有一个索引包括一个月的日志事件，但是，最让我们感兴趣的只是过去 1 小时内的日志事件：

[source,js]
--------------------------------------------------
GET /logs/2014-01/_search
{
    "query" : {
        "filtered" : {
            "filter" : {
                "range" : {
                    "timestamp" : {
                        "gt" : "now-1h"
                    }
                }
            }
        }
    }
}
--------------------------------------------------

这个过滤器不会被缓存，因为使用了 `now` 函数，它的值每毫秒都在发生改变。((("now function", "filters using, caching and")))这意味着我们每次查询时都需要检查一个月的日志事件。

我们可以将这个查询与一个缓存过滤器结合，使查询变得更高效：增加固定时间点先排除绝大多数的日志，比如昨日深夜这个时间点：

[source,js]
--------------------------------------------------
"bool": {
    "must": [
        { "range" : {
            "timestamp" : {
                "gt" : "now-1h/d" <1>
            }
        }},
        { "range" : {
            "timestamp" : {
                "gt" : "now-1h" <2>
            }
        }}
    ]
}
--------------------------------------------------
<1> 这个过滤器会被缓存，因为它将 `now` 取整至昨日深夜。

<2> 这个过滤器不被缓存，因为它使用的 `now` _没有_ 取整。

语句 `now-1h/d` 将时间截取至昨日深夜，这能将今日之前的所有文档都排除。结果的 bitset 之所以会被缓存是因为 `now` 与取整结合使用，这意味着它每天只会被计算一次，即当 _昨日深夜（midnight-last-night）_ 这个值发生变化的时候。语句  `now-1h` 之所以没被缓存是因为 `now` 函数生成的精确时间每毫秒都在变化。由于第一个过滤器可以先帮我们过滤掉今日之前的所有文档，所以第二个过滤器只会检查剩下的文档。

语句的顺序非常重要，这个方法只在 _深夜之前（since-midnight）_ 语句置于 _过去一小时（last-hour）_ 语句之前时才有效。如果顺序相反，那么 _过去一小时（last-hour）_ 语句就要检查索引中的所有文档，而非当天创建的文档。
